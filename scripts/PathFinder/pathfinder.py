#!/usr/bin/env python
""" 
=) This program blablabla 
"""

from threading import Thread
import subprocess
import argparse
import time

class Pathfinder:
    """ Put everything together... """
    def __init__(self):
        self.args = argparse.ArgumentParser(
                prog="Pathfinder",
                description="Automate the process of finding potential vectors of initial access",
                epilog="..."
        )

    def argparser(self):
        """ temp """

    def putting_it_together(self):
        """ temp """


class NmapPathcheck:
    """ Use nmap and save the output for further analyzing """
    def __init__(self, name):
        self.name = name

    def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        time.sleep(2)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


class CrackmapexecPathcheck:
    """ Use cme and save the output for further analyzing """
    def __init__(self, name):
        self.name = name

    def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        time.sleep(2)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


class Enum4linuxPathcheck:
    """ Use enum4linux and save the output for further analyzing """
    def __init__(self, name):
        self.name = name

    def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        time.sleep(2)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """
        try:
            result = subprocess.run(['ls'], check=True)
            print(result)
        except subprocess.CalledProcessError as e:
            print(f"Command {e.cmd} exited with error {e.returncode}")


class CmsPathcheck:
    """ Use various cms programs and save the output for further analyzing """
    def __init__(self, name):
        self.name = name

    def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        time.sleep(2)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


class NiktoPathcheck:
    """ Use nikto and save the output for further analyzing """
    def __init__(self, name):
        self.name = name

    def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        time.sleep(2)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


class FuzzingPathcheck:
    """ Use various fuzzing programs and save the output for further analyzing """
    def __init__(self, name):
        self.name = name

    def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        time.sleep(2)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


def main():
    """ main function of program """
    pathfinder = Pathfinder()
    pathfinder.argparser()

    nmap_pc = NmapPathcheck("Task1")
    cme_pc = CrackmapexecPathcheck("Task2")
    e4l_pc = Enum4linuxPathcheck("Task3")
    cms_pc = CmsPathcheck("Task4")
    nikto_pc = NiktoPathcheck("Task5")
    fuzzing_pc = FuzzingPathcheck("Task6")

    class_tasks = [nmap_pc, cme_pc, e4l_pc, cms_pc, nikto_pc, fuzzing_pc]
    threads = [Thread(target=i) for i in class_tasks]
    started_threads = []

    for thread in threads:
        thread.start()
        started_threads.append(thread)

    for thread in started_threads:
        thread.join()

if __name__ == '__main__':
    main()
