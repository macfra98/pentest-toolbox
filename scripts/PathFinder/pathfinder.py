#!/usr/bin/env python
""" 
=) This program blablabla 
"""

import asyncio
import subprocess
import argparse
import time

class Pathfinder:
    """ Put everything together... """
    def __init__(self):
        self.parser = argparse.ArgumentParser(
                prog="Pathfinder",
                description="Automate the process of finding potential vectors of initial access",
                epilog="Example: pathfinder -i 127.0.0.1"
        )
        self.args = None
        self.address = None

    def argparser(self):
        """ add argument and set variable to it """
        self.parser.add_argument('-i', '--address', required=True, help="IP address of a target")
        self.args = vars(self.parser.parse_args())

        for _, addr in self.args.items():
            self.address = addr

    def putting_it_together(self):
        """ temp """
    
    @property
    def address_getter(self):
        """ getter for address """
        return self.address


class PortGrab:
    def __init__(self, ip):
        self.ip = ip
        self.ports = []

    def nmap_portscan(self):
        """ Nmap scan of specific address """
        command_port_detection = [
            'nmap', '-p-', f'{self.ip}', '--open'
        ]

        result = subprocess.run(
                command_port_detection, 
                stdout=asyncio.subprocess.PIPE, 
                stderr=asyncio.subprocess.PIPE,
                text=True
        )
        
        res_split = result.stdout.split('\n')  
        temp_split = [temp.split('open') for temp in res_split]
        
        # Grab the port strings and convert to integers and append to portlist
        for temp in temp_split:
            for split in temp:
                try:
                    if ('/tcp' in split): 
                        if int(split.split('/tcp')[0]):
                            port = int(split.split('/tcp')[0])
                            self.ports.append(port)
                    elif ('/udp' in split):
                        if int(split.split('/udp')[0]):
                            port = int(split.split('/udp')[0])
                            self.ports.append(port)
                except ValueError as e:
                    # Continue as errors will only be used as a convert check...
                    continue

        return self.ports

    @property
    def ports_getter(self):
        return self.ports

class NmapPathcheck:
    """ Use nmap and save the output for further analyzing """
    def __init__(self, name, ip, ports):
        self.name = name
        self.ip = ip
        self.ports = ports
        self.ports_string = ""
        self.text = """"""

    async def nmap_scan(self):
        for port in self.ports:
            self.ports_string += f'{port},'
        self.ports_string = self.ports_string[:-1]

        command_vuln_ver_script_detection = [
            'nmap', '-p', f'{self.ports_string}', '-sV', '-sC',
            '--script=vuln', f'{self.ip}', '-T5'
        ]
        
        result = subprocess.run(command_vuln_ver_script_detection, check=True, capture_output=True, text=True)
        #TODO: split by VULNERABLE ?
        test = result.stdout.split('|')

        with open("demo.html", 'w') as f:
            for x in test:
                f.write(f"<br><p>{x}</p></br>")

    async def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        await self.nmap_scan()
        print(f"{self.name} finished")
    

class CrackmapexecPathcheck:
    """ Use cme and save the output for further analyzing """
    def __init__(self, name, ports):
        self.name = name
        self.ports = ports

    async def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        await asyncio.sleep(5)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


class Enum4linuxPathcheck:
    """ Use enum4linux and save the output for further analyzing """
    def __init__(self, name, ports):
        self.name = name
        self.ports = ports

    async def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        await asyncio.sleep(5)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """
        try:
            result = subprocess.run(['ls'], check=True)
            print(result)
        except subprocess.CalledProcessError as e:
            print(f"Command {e.cmd} exited with error {e.returncode}")


class CmsPathcheck:
    """ Use various cms programs and save the output for further analyzing """
    def __init__(self, name, ports):
        self.name = name
        self.ports = ports

    async def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        await asyncio.sleep(5)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


class NiktoPathcheck:
    """ Use nikto and save the output for further analyzing """
    def __init__(self, name, ports):
        self.name = name
        self.ports = ports

    async def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        await asyncio.sleep(5)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


class FuzzingPathcheck:
    """ Use various fuzzing programs and save the output for further analyzing """
    def __init__(self, name, ports):
        self.name = name
        self.ports = ports

    async def __call__(self):
        """ Call all tasks within class """
        print(f"Performing task {self.name}")
        await asyncio.sleep(5)
        print(f"{self.name} finished")

    def tempname(self):
        """ temp docstring """


async def main():
    """ main function of program """
    pathfinder = Pathfinder()
    pathfinder.argparser()

    portgrab = PortGrab(pathfinder.address_getter)
    ports = portgrab.nmap_portscan()

    cme_pc = CrackmapexecPathcheck("Task1", ports)
    e4l_pc = Enum4linuxPathcheck("Task2", ports)
    cms_pc = CmsPathcheck("Task3", ports)
    nikto_pc = NiktoPathcheck("Task4", ports)
    fuzzing_pc = FuzzingPathcheck("Task5", ports)
    nmap_pc = NmapPathcheck("Task6", pathfinder.address_getter, ports)

    class_tasks = [cme_pc, e4l_pc, cms_pc, nikto_pc, fuzzing_pc, nmap_pc]
    await asyncio.gather(*[task() for task in class_tasks])

if __name__ == '__main__':
    asyncio.run(main())
