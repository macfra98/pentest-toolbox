import argparse
import hashlib
import threading
import subprocess
import re

try:
    from identify_hash import match_hash
except ImportError:
    from .identify_hash import match_hash

class Cracker:
    def __init__(self):
        self.parser = argparse.ArgumentParser(description='Crack passwords =)')
        self.args = None

        self.mode = None
        self.hash = None
        self.hash_fn = None

        self.wordlist = None
        self.wordlist_count = 0

        self.hashfile = None
        self.threads = None

        self.can_crack = False
        self.selected_mode = False

        self.possible_hashes = []
        self.supported_hashes = hashlib.algorithms_available
    
    def init_args(self):
        self.parser.add_argument('-w', '--wordlist', required=True, help="File of passwords,\
                list of password or a single password") 
        self.parser.add_argument('-f', '--hashfile', required=True, help="File of hashes, \
                list of hashes or a single hash")
        self.parser.add_argument('-t', '--threads', default=5, help="Amount of threads (more = faster)")
        self.parser.add_argument('-m', '--mode', help="Hash mode, typ of hash to crack")
        self.args = vars(self.parser.parse_args())

    def set_args(self):
        for arg, v in self.args.items():
            if arg == 'mode':
                self.mode = v
            elif arg == 'wordlist':
                self.wordlist = v
            elif arg == 'hashfile':
                self.hashfile = v
            elif arg == 'threads':
                self.threads = v
            else:
                continue
    
    def hash_mode(self): 
        if self.mode:
            your_hashtype = re.sub(r'\W+', '', f"{self.mode}").lower()
            for k, v in self.supported_hashes.items():
                supported_hash = k
                if your_hashtype == supported_hash:
                    print(f"[+] Supported hash, using {your_hashtype}") 
                    self.can_crack = True
                    self.selected_mode = supported_hash
                    self.hash = v
                    break
            if supported_hash != your_hashtype:
                print(f"[-] Unsupported hash, exitig.")
                quit(1)
        else:
            with open(f"{self.hashfile}", "r") as f:
                hash = f.read().strip()
                self.hash = hash

            print("[!] Based on the hashfile...\n")

            for k, v in match_hash(hash).items():
                self.possible_hashes.append(k)

            while True:
                try:
                    mode = int(input("[->] "))
                    while_check = int(mode) 

                    if -1 < while_check < len(self.possible_hashes):
                        self.mode = self.possible_hashes[mode]
                        your_hashtype = re.sub(r'\W+', '', f"{self.mode}").lower()
                        for k in self.supported_hashes:
                            supported_hash = k
                            if your_hashtype == supported_hash:
                                print(f"[+] Supported hash, using {your_hashtype}") 
                                self.can_crack = True
                                self.selected_mode = supported_hash
                                break
                        if supported_hash != your_hashtype:
                            print(f"[-] Unsupported hash, exitig.")
                            quit(1)
                        break
                    else:
                        print(f"[!] Can only accept numbers within range of list. 0 - {len(self.possible_hashes)-1}")
                except ValueError:
                    print(f"[!] Must be an integer.")
                    
        self.hash_fn = getattr(hashlib, self.selected_mode, None)

    def wordlist_information(self):
        line_count = subprocess.run(['wc', '-l', f'{self.wordlist}'], stdout=subprocess.PIPE, text=True)
        self.wordlist_count = line_count.stdout.split(' ')[0]
 
    def crack(self, thread_id, thread_amount):
        count_div = int(int(self.wordlist_count) / int(thread_amount))
     
        if self.can_crack:
            with open(f"{self.wordlist}", "r") as wordlist:
                
                for _ in range(thread_id*count_div):
                    next(wordlist)

                for password in wordlist:
                    if self.hash_fn(password.strip().encode()).hexdigest() == self.hash:
                        print(f"[+] Cracked: {self.hash}:{password}")
                        return password
    
    def crack_with_threads(self):
        threads = self.threads
        list_of_threads = {}
        
        for i in range(int(threads)):
            list_of_threads[i] = threading.Thread(target=self.crack, args=(i, threads))

        for i, thread in list_of_threads.items():
            thread.start()

        for i, thread in list_of_threads.items():
            thread.join()
            
def main():
    cracker = Cracker()

    cracker.init_args()
    cracker.set_args()
    cracker.hash_mode() 
    cracker.wordlist_information()
    cracker.crack_with_threads()

    #cracker.crack()
    print("done")

if __name__ == '__main__':
    main()
