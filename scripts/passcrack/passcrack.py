import argparse
import hashlib
import re

try:
    from identify_hash import match_hash
except ImportError:
    from .identify_hash import match_hash

class Cracker:
    def __init__(self):
        self.parser = argparse.ArgumentParser(description='Crack passwords =)')
        self.args = None

        self.mode = None
        self.wordlist = None
        self.hashfile = None
        self.threads = None

        self.can_crack = False
        self.selected_mode = False

        self.possible_hashes = []
        self.supported_hashes = hashlib.algorithms_available
    
    def init_args(self):
        self.parser.add_argument('-w', '--wordlist', required=True, help="File of passwords,\
                list of password or a single password") 
        self.parser.add_argument('-f', '--hashfile', required=True, help="File of hashes, \
                list of hashes or a single hash")
        self.parser.add_argument('-t', '--threads', help="Amount of threads (more = faster)")
        self.parser.add_argument('-m', '--mode', help="Hash mode, typ of hash to crack")
        self.args = vars(self.parser.parse_args())

    def set_args(self):
        for arg, v in self.args.items():
            if arg == 'mode':
                self.mode = v
            elif arg == 'wordlist':
                self.wordlist = v
            elif arg == 'hashfile':
                self.hashfile = v
            elif arg == 'threads':
                self.threads = v
            else:
                continue
    
    def hash_mode(self): 
        if self.mode:
            your_hashtype = re.sub(r'\W+', '', f"{self.mode}").lower()
            for k, v in self.supported_hashes.items():
                supported_hash = k
                if your_hashtype == supported_hash:
                    print(f"[+] Supported hash, using {your_hashtype}") 
                    self.can_crack = True
                    self.selected_mode = supported_hash
                    break
            if supported_hash != your_hashtype:
                print(f"[-] Unsupported hash, exitig.")
                quit(1)
        else:
            with open(f"{self.hashfile}", "r") as f:
                hash = f.read().strip()

            print("[!] Based on the hashfile...\n")

            for k, v in match_hash(hash).items():
                self.possible_hashes.append(k)

            while True:
                try:
                    mode = int(input("[->] "))
                    while_check = int(mode) 

                    if -1 < while_check < len(self.possible_hashes):
                        self.mode = self.possible_hashes[mode]
                        your_hashtype = re.sub(r'\W+', '', f"{self.mode}").lower()
                        for k in self.supported_hashes:
                            supported_hash = k
                            if your_hashtype == supported_hash:
                                print(f"[+] Supported hash, using {your_hashtype}") 
                                self.can_crack = True
                                self.selected_mode = supported_hash
                                break
                        if supported_hash != your_hashtype:
                            print(f"[-] Unsupported hash, exitig.")
                            quit(1)
                        break
                    else:
                        print(f"[!] Can only accept numbers within range of list. 0 - {len(self.possible_hashes)-1}")
                except ValueError:
                    print(f"[!] Must be an integer.")

    
    def crack(self):
        if self.can_crack:
            print(self.selected_mode)
            
def main():
    cracker = Cracker()

    cracker.init_args()
    cracker.set_args()
    cracker.hash_mode()
    cracker.crack()

if __name__ == '__main__':
    main()
