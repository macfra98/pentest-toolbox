import argparse
import hashlib
import threading
import subprocess
import time
import re

from multiprocessing import Manager, Pool, Queue

try:
    from identify_hash import match_hash
except ImportError:
    from .identify_hash import match_hash

class Cracker:
    def __init__(self, threads, wordlist, hashfile, mode,
                 selected_mode, can_crack, hash_fn, hash, process_divider):
        self.args = None
        self.process_divider = process_divider

        self.mode = mode
        self.hash = hash
        self.hash_fn = hash_fn

        self.wordlist = wordlist
        self.wordlist_count = 0

        self.hashfile = hashfile
        self.threads = threads

        self.can_crack = can_crack
        self.selected_mode = selected_mode

        self.possible_hashes = []
        self.supported_hashes = hashlib.algorithms_available

        self.password_cracked = False
    
    def wordlist_information(self):
        line_count = subprocess.run(['wc', '-l', f'{self.wordlist}'], stdout=subprocess.PIPE, text=True)
        self.wordlist_count = int(line_count.stdout.split()[0])

    def crack(self, thread_id, thread_amount, hash_fn_name):
        hash_fn = getattr(hashlib, hash_fn_name, None)
        if not hash_fn:
            print(f"[-] Unsupported hash function: {hash_fn_name}")
            return
        
        if self.process_divider is not None:
            count_div = int(self.wordlist_count / (self.process_divider * thread_amount))
        else:
            count_div = int(self.wordlist_count / thread_amount)

        start_line = thread_id * count_div 
    
        # for debugging
        print("Threads: ", thread_amount)
        print("Process_divider: ", self.process_divider)
        print("Wordlistcount: ", self.wordlist_count)
        print("Count_div: ", count_div)
        print("Thread_id: ", thread_id)
     
        with open(self.wordlist, "r", encoding="utf-8") as wordlist:
            for _ in range(start_line):
                next(wordlist)
                     
            for i, password in enumerate(wordlist, start=1):
                if i > count_div:
                    break

                if hash_fn(password.strip().encode()).hexdigest() == self.hash:
                    self.password_cracked = password
                    return self.password_cracked

    def worker(self, threads, cracked):
        list_of_threads = {}
        
        for i in range(int(threads)):
            list_of_threads[i] = threading.Thread(target=self.crack, args=(i, threads, self.selected_mode))

        for thread in list_of_threads.values():
            thread.start()

        for thread in list_of_threads.values():
            thread.join()
        
        return  self.password_cracked

class Hashmode:
    def __init__(self):
        self.mode = None
        self.parser = argparse.ArgumentParser(description='Crack passwords =)')

        self.args = None

        self.hashfile = None
        self.hash = None
        self.hash_fn = None

        self.can_crack = False
        self.selected_mode = False

        self.possible_hashes = []
        self.supported_hashes = hashlib.algorithms_available

    def init_args(self):
        self.parser.add_argument('-w', '--wordlist', required=True, help="File of passwords,\
                list of password or a single password") 
        self.parser.add_argument('-f', '--hashfile', required=True, help="File of hashes, \
                list of hashes or a single hash")
        self.parser.add_argument('-t', '--threads', default=5, help="Amount of threads (more = faster)")
        self.parser.add_argument('-m', '--mode', help="Hash mode, type of hash to crack")
        self.parser.add_argument('-c', '--cpus', default=4, help="Amount of CPUs (more = faster)")
        self.args = vars(self.parser.parse_args())

    def set_args(self):
        for arg, v in self.args.items():
            setattr(self, arg, v)

    def hash_mode(self): 
        if self.mode:
            your_hashtype = re.sub(r'\W+', '', f"{self.mode}").lower()
            for k, v in self.supported_hashes.items():
                supported_hash = k
                if your_hashtype == supported_hash:
                    print(f"[+] Supported hash, using {your_hashtype}") 
                    self.can_crack = True
                    self.selected_mode = supported_hash
                    self.hash = v
                    break
            if supported_hash != your_hashtype:
                print(f"[-] Unsupported hash, exitig.")
                quit(1)
        else:
            with open(f"{self.hashfile}", "r") as f:
                hash = f.read().strip()
                self.hash = hash

            print("[!] Based on the hashfile...\n")

            for k, v in match_hash(hash).items():
                self.possible_hashes.append(k)

            while True:
                try:
                    mode = int(input("[->] "))
                    while_check = int(mode) 

                    if -1 < while_check < len(self.possible_hashes):
                        self.mode = self.possible_hashes[mode]
                        your_hashtype = re.sub(r'\W+', '', f"{self.mode}").lower()
                        for k in self.supported_hashes:
                            supported_hash = k
                            if your_hashtype == supported_hash:
                                print(f"[+] Supported hash, using {your_hashtype}") 
                                self.can_crack = True
                                self.selected_mode = supported_hash
                                break
                        if supported_hash != your_hashtype:
                            print(f"[-] Unsupported hash, exitig.")
                            quit(1)
                        break
                    else:
                        print(f"[!] Can only accept numbers within range of list. 0 - {len(self.possible_hashes)-1}")
                except ValueError:
                    print(f"[!] Must be an integer.")
                    
        self.hash_fn = getattr(hashlib, self.selected_mode, None)

        return [self.args, {"can_crack": self.can_crack,
                            "hash": self.hash, "selected_mode" : self.selected_mode,
                            "hash_fn" : self.hash_fn}] 


def multiprocessing_func(input_data, task_completed, return_queue):
    process_divider = None
    cracked = False
    cracked_pw = ""

    try:
        for k,v in input_data[0].items():
            if k in [1,2,3,4,
                     5,6,7,8,
                     9,10,11,
                     12,13,14,
                     15,16]:

                process_divider = int(k) 
                break
    except ValueError:
        pass # ...

    selected_mode = input_data[0]['selected_mode']
    can_crack = input_data[0]['can_crack']
    wordlist = input_data[0]['wordlist']
    hashfile = input_data[0]['hashfile']
    hash_fn = input_data[0]['hash_fn']
    threads = input_data[0]['threads']
    mode = input_data[0]['mode']
    hash = input_data[0]['hash']
    
    # Check if the task is already completed by another process
    if task_completed.is_set():
        pass
    else:
    # cracker instances
        cracker_instance = Cracker(threads, wordlist, hashfile, mode,
                                   selected_mode, can_crack, hash_fn, hash, process_divider)

        cracker_instance.wordlist_information()
        cracked = cracker_instance.worker(threads, cracked)

    if cracked:
        return_queue.put(cracked)
        task_completed.set()
        return cracked

def main():
    start_time = time.time()

    hashmode = Hashmode()
    hashmode.init_args()
    hashmode.set_args()
    args = hashmode.hash_mode()

    combined_dict = args[0] | args[1]
    t = int(combined_dict['threads']) 

    input_data = []
    process_specific_dict = {}

    for i in range(t+1):
        combined_dict['threads'] = i
 
    for i in range(t):
        process_specific_dict = combined_dict.copy()
        
        # Making unique IDs for each process
        modifying_key = i + 1
        process_specific_dict[modifying_key] = 0.1 * (i + 1)
        input_data.append((process_specific_dict,))
    
    manager = Manager()
    task_completed = manager.Event()
    return_queue = manager.Queue()

    starmap_data = [(process_data_dict, task_completed, return_queue) for process_data_dict in input_data]

    with Pool(processes=int(combined_dict['cpus'])) as pool:
        pool.starmap(multiprocessing_func, starmap_data)
    
    

    if not return_queue.empty():
        result = return_queue.get()
        print(f"[+] Cracked: {combined_dict['hash']}:{result}")

    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"TIME: {elapsed_time} seconds")


if __name__ == '__main__':
    main()

